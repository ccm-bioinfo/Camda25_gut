recta <- function(x) 1+5∗x # define una funci´on lineal “recta(x)”
set.seed(415)
x <- c(1:10)
y <- recta(x)+rnorm(10, 0, 5)
dev.new(width=6, height=5)
par(cex=1.5)
plot(x, y)
recta <- function(x) 1+5∗x
recta <- function(x) 1+5∗x
recta <- function(x) return 1+5∗x
recta <- function(x) return (1+5∗x)
recta <- function(x) return (1+5∗x)
recta <- function(x) {return (1+5∗x)}
recta <- function(x) return(x)
recta <- function(x) return(1+5*x)
recta <- function(x) return (1+5*x)
recta <- function(x) 1+5*x
x <- c(1:10)
y <- recta(x)+rnorm(10, 0, 5)
dev.new(width=6, height=5)
par(cex=1.5)
plot(x, y)
cor(x, y)
A <- lm(y ∼ x)
A <- lm(y ∼ x)
A <- lm(y ∼ x)
A <- lm(y∼x)
A <- lm(y ∼ x)
A <- lm(y ~ x)
print(A)
abline(A)
plot(A, which=1, add.smooth=FALSE)
abline(A)
print(A)
cor(x, y)
recta <- function(x) 1+5*x
x <- c(1:10)
y <- recta(x)+rnorm(10, 0, 5)
dev.new(width=6, height=5)
par(cex=1.5)
plot(x, y)
A <- lm(y ~ x)
print(A)
abline(A)
plot(A, which=1, add.smooth=FALSE)
recta <- function(x) 1+5*x
x <- c(1:10)
y <- recta(x)+rnorm(10, 0, 5)
dev.new(width=6, height=5)
par(cex=1.5)
plot(x, y)
cor(x, y)
A <- lm(y ~ x)
print(A)
abline(A)
plot(A, which=1, add.smooth=FALSE)
recta <- function(x) 1+5*x
set.seed(415)
x <- c(1:10)
y <- recta(x)+rnorm(10, 0, 5)
dev.new(width=6, height=5)
par(cex=1.5)
plot(x, y)
cor(x, y)
A <- lm(y ~ x)
print(A)
abline(A)
dev.new(width=6, height=5)
recta <- function(x) 1+5*x
set.seed(415)
x <- c(1:10)
y <- recta(x)+rnorm(10, 0, 5)
dev.new(width=6, height=5)
par(cex=1.5)
plot(x, y)
cor(x, y)
A <- lm(y ~ x)
print(A)
abline(A)
recta <- function(x) 1+5*x
set.seed(415)
x <- c(1:10)
y <- recta(x)+rnorm(10, 0, 5)
dev.new(width=6, height=5)
par(cex=1.5)
plot(x, y)
cor(x, y)
A <- lm(y ~ x)
print(A)
abline(A)
plot(A, which=1, add.smooth=FALSE)
vida <- c(130, 74, 150, 159, 138, 168, 155, 180, 188, 126, 110, 160, 34, 80, 135, 106, 174, 150, 40, 75, 122, 115, 120, 139, 20, 82, 25, 58, 96, 82, 70, 58, 70, 45, 104, 60)
material <- rep(c(1,1,2,2,3,3), 6)
temp <- rep(c(15, 70, 125), each=12)
dat <- data.frame(resp=vida, tipo=factor(material), temperatura=factor(temp))
fit <- aov(resp ∼ tipo∗temperatura, data=dat)
fit <- aov(resp∼tipo∗temperatura, data=dat)
fit <- aov(resp∼tipo*temperatura, data=dat)
fit <- aov(resp∼tipo*temperatura, data=dat)
fit <- aov(resp ∼ tipo * temperatura, data=dat)
fit <- aov(resp ∼ (tipo * temperatura), data=dat)
summary(fit)
fit <- aov(resp ∼ (tipo * temperatura), data=dat)
fit <- aov(resp ~ tipo * temp, data=dat)
summary(fit)
clear
musician <- data.frame(people = c("Medtner", "Radwimps", "Shakira"),
pieces = c(722,187,68),
likes = c(0,1,1))
musician
class(musician)
musician$people
musician$pieces + 20
typeof(musician$likes)
musician$likes <- as.logical(musician$likes)
paste("Is",musician$people, "popular? :", musician$likes, sep = " ")
musician[1,2]
musician[1,"pieces"]
(musician$pieces)/2
musician$likes <- c("TRUE","TRUE","TRUE")
ggplot(data= musician,
mapping = aes(x = people, y = pieces))
library(ggplot2)
ggplot(data= musician,
mapping = aes(x = people, y = pieces))
ggplot(data= musician,
mapping = aes(x = people, y = pieces)+geom_col())
ggplot(data= musician,
mapping = aes(x = people, y = pieces))
+geom_col())
ggplot(data= musician,
mapping = aes(x = people, y = pieces))
+geom_col()
ggplot(data= musician,
mapping = aes(x = people, y = pieces))+geom_col()
ggplot(data= musician,
mapping = aes(x = people, y = pieces))+geom_col(color = "blue")
ggplot(data= musician,
mapping = aes(x = people, y = pieces))+geom_col(color = "red")
ggplot(data= musician,
mapping = aes(x = people, y = pieces))+geom_col(aes(color= likes))
ggplot(data= musician,
mapping = aes(x = people, y = pieces))+geom_col(aes(color= likes)) + geom_point()
ggplot(data= musician,
mapping = aes(x = people, y = pieces)) + geom_point()
ggplot(data= musician,
mapping = aes(x = people, y = pieces))+geom_col(aes(color= likes)) + geom_point()
ggplot(data= musician,
mapping = aes(x = people, y = pieces, color = likes))+scale_color_manual(values = c("blue", "orange")) + geom_col() + geom_point()
?ggplot
?summary()
??barplot
??regression
install.packages("pals")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("phyloseq")
a
library("phyloseq")
library("biomartr")
BiocManager::install('biomartr')
a
library("biomartr")
biomartr::organismBM(organism = "Arabidopsis thaliana")
set.seed(123)
lt = list(a = sample(letters, 5),
b = sample(letters, 10),
c = sample(letters, 15))
m1 = make_comb_mat(lt)
library(devtools)
install.packages(devtools)
install.packages("devtools")
library(devtools)
install_github("jokergoo/ComplexHeatmap")
set.seed(123)
lt = list(a = sample(letters, 5),
b = sample(letters, 10),
c = sample(letters, 15))
m1 = make_comb_mat(lt)
setwd("C:/Users/rafap/Documents/metagenomica/camda2024/Camda25_gut/DataSets/CAMDA_2025/")
install.packages("igraph")
install.packages("igraph")
install.packages("vegan")          # for ecological data
install.packages("SpiecEasi")      # for network inference from count data
install.packages("microbiome")     # helpful for filtering, transformations
# Optional: for visualization
install.packages("ggraph")
install.packages("tidygraph")
data_tax<-read.table("taxa_corrected.txt", header = TRUE, sep="\t")
head(data_tax)
library(readr)
data_tax<-read_tsv("taxa_corrected.txt")
head(data_tax)
metadata<-read_tsv("metadata_corrected_final.txt")
head(metadata)
group_names <- unique(metadata$Group)
group_names
otu_by_group <- lapply(group_names, function(grp) {
samples <- meta$SampleID[meta$Group == grp]
data_tax[, samples, drop=FALSE]
})
otu_by_group <- lapply(group_names, function(grp) {
samples <- metadata$SampleID[metadata$Group == grp]
data_tax[, samples, drop=FALSE]
})
otu_by_group <- lapply(group_names, function(grp) {
samples <- metadata$sample[metadata$Group == grp]
data_tax[, samples, drop=FALSE]
})
names(otu_by_group) <- group_names
library(igraph)
build_network <- function(otu_group, method="spearman", cutoff=0.6, pval_cutoff=0.05) {
cor_matrix <- cor(t(otu_group), method=method)
p_matrix <- cor.mtest(t(otu_group), method=method)$p
# Apply thresholds
cor_matrix[abs(cor_matrix) < cutoff | p_matrix > pval_cutoff] <- 0
diag(cor_matrix) <- 0
# Build network
graph <- graph_from_adjacency_matrix(cor_matrix != 0, mode = "undirected", weighted = TRUE)
E(graph)$weight <- cor_matrix[cor_matrix != 0]
return(graph)
}
# Helper to get p-values
cor.mtest <- function(mat, method){
mat <- t(mat)
n <- ncol(mat)
p.mat<- matrix(NA, n, n)
colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
for(i in 1:(n - 1)){
for(j in (i + 1):n){
tmp <- cor.test(mat[,i], mat[,j], method=method)
p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
}
}
p.mat
}
networks <- lapply(otu_by_group, build_network)
warnings()
library(igraph)
build_network <- function(otu_group, method = "spearman", cutoff = 0.6, pval_cutoff = 0.05) {
otu_group <- filter_zero_var(otu_group)
if (nrow(otu_group) < 2) return(make_empty_graph())
cor_matrix <- cor(t(otu_group), method = method)
p_result <- cor.mtest(otu_group, method = method)
p_matrix <- p_result$p
# Filtrar por umbrales
cor_matrix[abs(cor_matrix) < cutoff | p_matrix > pval_cutoff] <- 0
diag(cor_matrix) <- 0
# Red igraph
g <- graph_from_adjacency_matrix(cor_matrix != 0, mode = "undirected", weighted = TRUE)
E(g)$weight <- cor_matrix[cor_matrix != 0]
return(g)
}
filter_zero_var <- function(df) {
df[apply(df, 1, function(x) sd(x) > 0), ]
}
# Helper to get p-values
cor.mtest <- function(mat, method) {
mat <- t(mat)
n <- ncol(mat)
p.mat <- matrix(NA, n, n)
colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
for(i in 1:(n - 1)) {
for(j in (i + 1):n) {
tmp <- tryCatch({
cor.test(mat[, i], mat[, j], method = method)
}, error = function(e) return(list(p.value = NA)))
p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
}
}
list(p = p.mat)
}
networks <- lapply(otu_by_group, build_network)
warnings()
library(igraph)
build_network <- function(otu_group, method = "spearman", cutoff = 0.6, pval_cutoff = 0.05) {
otu_group <- filter_zero_var(otu_group)
if (nrow(otu_group) < 2) return(make_empty_graph())
cor_matrix <- cor(t(otu_group), method = method)
p_result <- cor.mtest(otu_group, method = method)
p_matrix <- p_result$p
# Filtrar por umbral de correlación y p-valor solo en triángulo superior
keep <- which(upper.tri(cor_matrix) & abs(cor_matrix) >= cutoff & p_matrix <= pval_cutoff, arr.ind = TRUE)
# Si no hay aristas significativas, devolver grafo vacío con nodos
if (nrow(keep) == 0) {
return(make_empty_graph(n = ncol(otu_group), directed = FALSE) %>% set_vertex_attr("name", value = colnames(t(otu_group))))
}
edges <- data.frame(
from = colnames(cor_matrix)[keep[,1]],
to   = colnames(cor_matrix)[keep[,2]],
weight = cor_matrix[keep]
)
# Crear grafo con pesos
g <- graph_from_data_frame(edges, directed = FALSE)
return(g)
}
filter_zero_var <- function(df) {
df[apply(df, 1, function(x) sd(x) > 0), ]
}
# Helper to get p-values
cor.mtest <- function(mat, method) {
mat <- t(mat)
n <- ncol(mat)
p.mat <- matrix(NA, n, n)
colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
for(i in 1:(n - 1)) {
for(j in (i + 1):n) {
tmp <- tryCatch({
cor.test(mat[, i], mat[, j], method = method)
}, error = function(e) return(list(p.value = NA)))
p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
}
}
list(p = p.mat)
}
networks <- lapply(otu_by_group, build_network)
warnings()
library(igraph)
build_network <- function(otu_group, method = "spearman", cutoff = 0.6, pval_cutoff = 0.05) {
otu_group <- filter_zero_var(otu_group)
if (nrow(otu_group) < 2) return(make_empty_graph())
cor_matrix <- cor(t(otu_group), method = method)
p_result <- cor.mtest(otu_group, method = method)
p_matrix <- p_result$p
# Filtrar por umbral de correlación y p-valor solo en triángulo superior
keep <- which(upper.tri(cor_matrix) & abs(cor_matrix) >= cutoff & p_matrix <= pval_cutoff, arr.ind = TRUE)
# Verifica si hay aristas que conservar
if (length(keep) == 0) {
return(make_empty_graph(n = ncol(otu_group), directed = FALSE) %>%
set_vertex_attr("name", value = colnames(t(otu_group))))
}
# Extrae índices si hay aristas
from_ids <- colnames(cor_matrix)[keep[, 1]]
to_ids   <- colnames(cor_matrix)[keep[, 2]]
weights  <- cor_matrix[keep]
edges <- data.frame(
from = from_ids,
to   = to_ids,
weight = weights
)
# Crear grafo con pesos
g <- graph_from_data_frame(edges, directed = FALSE)
return(g)
}
filter_zero_var <- function(df) {
df[apply(df, 1, function(x) sd(x) > 0), ]
}
# Helper to get p-values
cor.mtest <- function(mat, method) {
mat <- t(mat)
n <- ncol(mat)
p.mat <- matrix(NA, n, n)
colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
for(i in 1:(n - 1)) {
for(j in (i + 1):n) {
tmp <- tryCatch({
cor.test(mat[, i], mat[, j], method = method)
}, error = function(e) return(list(p.value = NA)))
p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
}
}
list(p = p.mat)
}
networks <- lapply(otu_by_group, build_network)
warnings()
library(SpiecEasi)
library(igraph)
library(readr)
library(dplyr)
install.packages("remotes")
remotes::install_github("zdk123/SpiecEasi")
remotes::install_github("zdk123/SpiecEasi")
library(SpiecEasi)
library(igraph)
library(readr)
library(dplyr)
